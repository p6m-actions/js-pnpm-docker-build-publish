name: "JavaScript PNPM Docker Build and Publish"
description: "Builds and publishes a Docker image for a JavaScript application"
author: "Jimmie Fulton <jimmie.fulton@gmail.com>"

# Define the inputs for this action
inputs:
  project-path:
    description: "Relative path to the project directory containing package.json (must not contain '..' or be absolute)"
    required: false
    default: "."
  platforms:
    description: "The platforms to build for (comma-separated)"
    required: false
    default: "linux/amd64,linux/arm64"
  image-name:
    description: "The name for the Docker image (defaults to repository name)"
    required: false
    default: ""
  app-name:
    description: "Deprecated: Use 'image-name' instead. Alias for backward compatibility."
    required: false
    default: ""
  version:
    description: "The version to use for the Docker image (defaults to version from package.json)"
    required: false
    default: ""
  tag-latest:
    description: "Whether to also tag the image as 'latest'"
    required: false
    default: "true"
  dockerfile:
    description: "Path to the Dockerfile"
    required: false
    default: "Dockerfile"
  context:
    description: "Docker build context"
    required: false
    default: "."
  registry:
    description: "Docker registry URL"
    required: true

# Define the outputs for this action
outputs:
  image-digest:
    description: "The digest of the built Docker image"
    value: ${{ steps.build-image.outputs.digest }}
  image-name:
    description: "The full name of the built image (with version tag)"
    value: ${{ steps.build-image.outputs.image-name }}
  version:
    description: "The version used for tagging the image"
    value: ${{ steps.build-image.outputs.version }}

# Define the runs configuration
runs:
  using: "composite"
  steps:
    - name: Build and push Docker image
      id: build-image
      shell: bash
      run: |
        # Determine image name (prefer image-name, fall back to app-name for backward compatibility)
        if [ -n "${{ inputs.image-name }}" ]; then
          IMAGE_NAME="${{ inputs.image-name }}"
        elif [ -n "${{ inputs.app-name }}" ]; then
          echo "::warning::The 'app-name' input is deprecated. Please use 'image-name' instead."
          IMAGE_NAME="${{ inputs.app-name }}"
        else
          # Extract image name from repository name
          IMAGE_NAME=$(basename ${GITHUB_REPOSITORY})
        fi
        
        # Determine version
        if [ -n "${{ inputs.version }}" ]; then
          VERSION="${{ inputs.version }}"
        else
          # Extract version from package.json using pnpm
          PROJECT_PATH="${{ inputs.project-path }}"
          if [ -f "${PROJECT_PATH}/package.json" ]; then
            VERSION=$(cd "${PROJECT_PATH}" && pnpm -s pkg get version)
            # Remove quotes and whitespace
            VERSION="${VERSION//\"/}"
            VERSION="${VERSION//[[:space:]]/}"
            if [ -n "${VERSION}" ]; then
              echo "Extracted version from ${PROJECT_PATH}/package.json: ${VERSION}"
            else
              echo "::warning::Failed to extract version from ${PROJECT_PATH}/package.json. Using 'latest'."
              VERSION="latest"
            fi
          else
            echo "::warning::package.json not found at ${PROJECT_PATH}. Using 'latest'."
            VERSION="latest"
          fi
        fi
        
        # Build full image names
        VERSIONED_IMAGE="${{ inputs.registry }}/${IMAGE_NAME}:${VERSION}"
        
        # Build tag arguments
        TAGS="-t ${VERSIONED_IMAGE}"
        
        # Add latest tag if requested
        if [ "${{ inputs.tag-latest }}" = "true" ]; then
          LATEST_IMAGE="${{ inputs.registry }}/${IMAGE_NAME}:latest"
          TAGS="${TAGS} -t ${LATEST_IMAGE}"
        fi
        
        echo "Building and pushing Docker image: ${VERSIONED_IMAGE}"
        if [ "${{ inputs.tag-latest }}" = "true" ]; then
          echo "Also tagging as: ${LATEST_IMAGE}"
        fi
        
        # Build and push the image, capturing metadata for digest
        METADATA_FILE="${RUNNER_TEMP}/docker-metadata-$$.json"
        docker buildx build \
          --platform ${{ inputs.platforms }} \
          ${TAGS} \
          -f ${{ inputs.dockerfile }} \
          --push \
          --metadata-file "${METADATA_FILE}" \
          ${{ inputs.context }}

        # Get the image digest from build metadata
        if ! command -v jq &> /dev/null; then
          echo "::error::jq is required but not installed"
          exit 1
        fi

        if [ ! -f "${METADATA_FILE}" ]; then
          echo "::error::Build metadata file not found"
          exit 1
        fi

        DIGEST=$(jq -r '.["containerimage.digest"]' "${METADATA_FILE}") || {
          echo "::error::Failed to parse build metadata"
          exit 1
        }

        if [ -n "$DIGEST" ] && [ "$DIGEST" != "null" ]; then
          echo "Image digest: $DIGEST"
        else
          echo "::warning::No digest found in build metadata"
          DIGEST=""
        fi

        # Clean up metadata file
        rm -f "${METADATA_FILE}"
        
        # Set outputs
        echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
        echo "image-name=${VERSIONED_IMAGE}" >> $GITHUB_OUTPUT
        echo "version=${VERSION}" >> $GITHUB_OUTPUT

# Define the branding for the action in the GitHub Marketplace
branding:
  icon: "package"
  color: "blue"